// SPDX-License-Identifier: GPL-2.0-or-later
pragma solidity ^0.8.0;

import {PreLiquidation} from "../../PreLiquidation.sol";
import {Id} from "../../../lib/morpho-blue/src/interfaces/IMorpho.sol";

library PreLiquidationAddressLib {
    /// @notice Computes the CREATE2 address of the pre-liquidation contract generated by the `factory`
    /// for a specific Morpho market `id` with the pre-liquidation parameters `preLltv`, `preCF1`, `preCF2`, `preLIF1`,
    /// `preLIF2`, `preLiquidationOracle`.
    /// @param morpho Morpho's address.
    /// @param factory PreLiquidationFactory contract address.
    /// @param id Morpho market id for the pre-liquidation contract.
    ///  @param preLltv the maximum LTV of a position before allowing pre-liquidation.
    ///  @param preCF1 the close factor when the position LTV is equal to preLltv.
    ///  @param preCF2 the close factor when the position LTV is equal to LLTV.
    ///  @param preLIF1 the pre-liquidation incentive factor when the position LTV is equal to preLltv.
    ///  @param preLIF2 the pre-liquidation incentive factor when the position LTV is equal to LLTV.
    ///  @param preLiquidationOracle the oracle used to assess whether or not a position can be preliquidated.
    /// @return preLiquidationAddress The address of this pre-liquidation contract.
    function computePreLiquidationAddress(
        address morpho,
        address factory,
        Id id,
        uint256 preLltv,
        uint256 preCF1,
        uint256 preCF2,
        uint256 preLIF1,
        uint256 preLIF2,
        address preLiquidationOracle
    ) internal pure returns (address) {
        bytes32 init_code_hash = keccak256(
            abi.encodePacked(
                type(PreLiquidation).creationCode,
                abi.encode(morpho, id, preLltv, preCF1, preCF2, preLIF1, preLIF2, preLiquidationOracle)
            )
        );
        return address(uint160(uint256(keccak256(abi.encodePacked(uint8(0xff), factory, uint256(0), init_code_hash)))));
    }
}
